/* func callApi(urlApi string, data interface{}) interface{} {
	httpClient := http.Client{
		Timeout: time.Second * 2,
	}
	//Creation de la requete HTTP vers l'api
	req, _ := http.NewRequest(http.MethodGet, urlApi, nil)

	//Premet d'eviter la limit d'appelle à l'api ! Il faut le changer de temps en temps en cas de coupure !
	req.Header.Set("User_Agent", "oklolololo")

	//Envoie de la requete HTTP vers l'api !
	res, _ := httpClient.Do(req)
	if res.Body != nil {
		defer res.Body.Close()
	}

	body, _ := ioutil.ReadAll(res.Body)
	//Decodage de l'api !
	//Penser à changer la structure selon l'api !
	json.Unmarshal(body, data)
	return data
} */

//callApi(urlAPI, &Reponse)  === regarder pourquoi il y a un probleme ! avec l'adresse memoire ===



template index !!!

<body>
    <h3>Liste des artistes {{.Test}}</h3>
    <div id="listeArt">
        {{range .Liste}}
        <div class="cardArt">
            <p>Le nom {{.Name}}</p>
            <p>l'id du groupe ou de l'artiste est : {{.Id}}</p>
            <img src="{{.Image}}" alt="image">
            <p>Les menbres du groupe : {{.Members}}</p>
            <a class="btnCard" href="/{{.Id}}">Lien vers l'artiste pour plus dinformation</a>
        </div>
        {{end}}  
    </div>
</body>


	//var dateLocations []DateLocations

	/* for index := range date.Index {
		var contenu []Contenu
		joinTab := strings.Join(date.Index[index].Dates, " ")
		splitStr := strings.Split(joinTab, "*")
		for i, cnt := range splitStr {
			contenu = append(contenu, Contenu{location.Index[index].Location[i], cnt})
		}
		temp := DateLocations{date.Index[index].Id, contenu}
		dateLocations = append(dateLocations, temp)
		println("==================")
	}
	for i := range dateLocations {
		for h := range dateLocations[i].Contenu {
			println(dateLocations[i].Id, dateLocations[i].Contenu[h].Location, dateLocations[i].Contenu[h].Dates)
		}
		println("================================")
	} */

	/* 	for indexLocation := range location.Index {
		for _, cnt := range location.Index[index].Location {
			println(cnt)
		}
		for i, cnt := range splitStr {
			println(cnt)
		}
		println("==================")
	} */


    for index := range dateLocations {
		for i := range dateLocations[index].Contenu {
			println(dateLocations[index].Id, dateLocations[index].Contenu[i].Location, dateLocations[index].Contenu[i].Dates)
		}
	}


	 <h3>Card Artiste / Groupe !</h3>
    <p>Le nom {{.Artist.Name}}</p>
    <p>{{.Artist.DateCrea}}</p>
    <p>{{.Artist.DateAlbum}}</p>
    <p>l'id du groupe ou de l'artiste est : {{.Artist.Id}}</p>
   <img src="{{.Artist.Image}}" alt="image">
    <p>Les menbres du groupe :</p>
    {{range .Artist.Members}}
    <p>{{.}}</p>
    {{end}}
    <p>Liste des concerts :</p>
    {{range .Contenu.Contenu}}
    <p> Lieux : {{.Location}}, date : {{.Dates}}</p>
    {{end}}

	============================================================================

///////////////////// 01

	/* var artists []Artist
	var groupes []Artist
	for indexMain, contentsMain := range main {
		if len(contentsMain.Members) > 1 {
			groupes = append(groupes, main[indexMain])
		} else {
			artists = append(artists, main[indexMain])
		}
	} */



 ////////////// 02

	/* type Contenu struct {
		Location string
		Dates    string
	}

	type DateLocations struct {
		Id      int
		Contenu []Contenu
	} */

	/* var dateLocations []DateLocations
	for indexLocation := range location.Index {
		var contenu []Contenu
		joinTab := strings.Join(date.Index[indexLocation].Dates, " ")
		splitStr := strings.Split(joinTab, "*")
		splitStr = splitStr[1:]
		for i, cnt := range location.Index[indexLocation].Location {
			//println(cnt, splitStr[i], i)
			contenu = append(contenu, Contenu{cnt, splitStr[i]})
		}
		temp := DateLocations{location.Index[indexLocation].Id, contenu}
		dateLocations = append(dateLocations, temp)
	}
	return dateLocations */
